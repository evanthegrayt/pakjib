#!/usr/bin/env ruby

require 'optparse'
require_relative '../lib/spoonerise'

USAGE = 'USAGE: %s [OPTIONS] [WORDS]...' % [File.basename(__FILE__)]

def instantiate
  yield
rescue Spoonerise::JakPibError
  abort('Please pass more flip-able words.')
end

def save?
  @save
end

def map?
  @map
end

def print?
  @print
end

##
# Read in args and set options
opts = {}
OptionParser.new do |o|
  o.banner = USAGE
  o.on('-r', '--[no-]reverse', 'Reverse flipping') do |v|
    opts['reverse'] = v
  end
  o.on('-l', '--[no-]lazy', 'Skip small words') do |v|
    opts['lazy'] = v
  end
  o.on('-m', '--[no-]map', 'Print words mapping') do |v|
    @map = v
  end
  o.on('-p', '--[no-]print', 'Print all entries in the log') do |v|
    @print = v
  end
  o.on('-s', '--[no-]save', 'Save results in log') do |v|
    @save = v
  end
  o.on('--exclude=WORDS', Array, 'Words to skip') do |v|
    opts['exclude'] = v
  end
end.parse!(ARGV)

if print?
  s = Spoonerise::Log.new(File.join(__dir__, '..', 'log', 'spoonerise.csv'))
  s.each { |row| print row.join(' | ') + "\n" }
  exit
end

abort(USAGE) if ARGV.empty?

##
# Create instance of Spoonerism. I rescue the custom error and replace it with
# a more command-line friendly message.
words = instantiate do
  Spoonerise::Spoonerism.new(ARGV) do |s|
    opts.each { |k, v| s.send("#{k}=", v) }
  end
end

##
# If user passed `-s`, save to log file; otherwise, just print results as string
if save?
  puts "Saving [#{words.to_s}] to #{words.logfile_name}"
  words.save
else
  puts words.to_s
  if map?
    longest_key_size = words.spoonerise.group_by(&:size).max.first.size
    words.to_h.each { |k, v| puts "%-#{longest_key_size}s => %s" % [k, v] }
  end
end

